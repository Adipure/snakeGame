{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useState } from 'react';\nimport { SEGMENT_SIZE } from '../draw/draw';\nimport randomPositionOnGrid from '../utils/randomPositionOnGrid';\nimport useInterval from '../utils/useInterval';\nimport { GameState } from './Game';\nimport createSnakeMovement, { hasSnakeEatenItself, willSnakeHitTheFood } from './movement';\nexport let Direction;\n\n(function (Direction) {\n  Direction[Direction[\"UP\"] = 0] = \"UP\";\n  Direction[Direction[\"DOWN\"] = 1] = \"DOWN\";\n  Direction[Direction[\"LEFT\"] = 2] = \"LEFT\";\n  Direction[Direction[\"RIGHT\"] = 3] = \"RIGHT\";\n})(Direction || (Direction = {}));\n\nconst MOVEMENT_SPEED = 100;\n\nconst useGameLogic = _ref => {\n  _s();\n\n  let {\n    canvasHeight,\n    canvasWidth,\n    onGameOver,\n    gameState\n  } = _ref;\n  const [direction, setDirection] = useState();\n  const [snakeBody, setSnakeBody] = useState([{\n    x: 0,\n    y: 0\n  }]);\n\n  const resetGameState = () => {\n    setDirection(undefined);\n    setFoodPosition({\n      x: randomPositionOnGrid({\n        gridSize: SEGMENT_SIZE,\n        threshold: canvasWidth\n      }),\n      y: randomPositionOnGrid({\n        gridSize: SEGMENT_SIZE,\n        threshold: canvasHeight\n      })\n    });\n    setSnakeBody([{\n      x: randomPositionOnGrid({\n        gridSize: SEGMENT_SIZE,\n        threshold: canvasWidth\n      }),\n      y: randomPositionOnGrid({\n        gridSize: SEGMENT_SIZE,\n        threshold: canvasHeight\n      })\n    }]);\n  };\n\n  const [foodPosition, setFoodPosition] = useState();\n  const snakeHeadPosition = snakeBody[snakeBody.length - 1];\n  const {\n    moveDown,\n    moveUp,\n    moveLeft,\n    moveRight\n  } = createSnakeMovement();\n  useEffect(() => {\n    if (!canvasHeight || !canvasWidth) {\n      return;\n    }\n\n    setFoodPosition({\n      x: randomPositionOnGrid({\n        gridSize: SEGMENT_SIZE,\n        threshold: canvasWidth\n      }),\n      y: randomPositionOnGrid({\n        gridSize: SEGMENT_SIZE,\n        threshold: canvasHeight\n      })\n    });\n    setSnakeBody([{\n      x: randomPositionOnGrid({\n        gridSize: SEGMENT_SIZE,\n        threshold: canvasWidth\n      }),\n      y: randomPositionOnGrid({\n        gridSize: SEGMENT_SIZE,\n        threshold: canvasHeight\n      })\n    }]);\n  }, [canvasHeight, canvasWidth]);\n\n  const onKeyDownHandler = event => {\n    switch (event.code) {\n      case 'KeyS':\n        if (direction !== Direction.UP) {\n          setDirection(Direction.DOWN);\n        }\n\n        break;\n\n      case 'KeyW':\n        if (direction !== Direction.DOWN) {\n          setDirection(Direction.UP);\n        }\n\n        break;\n\n      case 'KeyD':\n        if (direction !== Direction.LEFT) {\n          setDirection(Direction.RIGHT);\n        }\n\n        break;\n\n      case 'KeyA':\n        if (direction !== Direction.RIGHT) {\n          setDirection(Direction.LEFT);\n        }\n\n        break;\n    }\n  };\n\n  const moveSnake = () => {\n    let snakeBodyAfterMovement;\n\n    switch (direction) {\n      case Direction.UP:\n        if (snakeHeadPosition.y > 0) {\n          snakeBodyAfterMovement = moveUp(snakeBody);\n        } else if (canvasWidth && snakeHeadPosition.x > canvasWidth / 2) {\n          setDirection(Direction.LEFT);\n        } else {\n          setDirection(Direction.RIGHT);\n        }\n\n        break;\n\n      case Direction.DOWN:\n        if (canvasHeight && snakeHeadPosition.y < canvasHeight - SEGMENT_SIZE) {\n          snakeBodyAfterMovement = moveDown(snakeBody);\n        } else if (canvasWidth && snakeHeadPosition.x > canvasWidth / 2) {\n          setDirection(Direction.LEFT);\n        } else {\n          setDirection(Direction.RIGHT);\n        }\n\n        break;\n\n      case Direction.LEFT:\n        if (snakeHeadPosition.x > 0) {\n          snakeBodyAfterMovement = moveLeft(snakeBody);\n        } else if (canvasHeight && snakeHeadPosition.y < canvasHeight / 2) {\n          setDirection(Direction.DOWN);\n        } else {\n          setDirection(Direction.UP);\n        }\n\n        break;\n\n      case Direction.RIGHT:\n        if (canvasWidth && snakeHeadPosition.x < canvasWidth - SEGMENT_SIZE) {\n          snakeBodyAfterMovement = moveRight(snakeBody);\n        } else if (canvasHeight && snakeHeadPosition.y < canvasHeight / 2) {\n          setDirection(Direction.DOWN);\n        } else {\n          setDirection(Direction.UP);\n        }\n\n        break;\n    } //snake eats itself\n\n\n    if (snakeBodyAfterMovement) {\n      const isGameOver = hasSnakeEatenItself(snakeBodyAfterMovement);\n\n      if (isGameOver) {\n        onGameOver();\n      }\n    }\n\n    if (direction !== undefined && foodPosition && willSnakeHitTheFood({\n      foodPosition,\n      snakeHeadPosition,\n      direction\n    })) {\n      setSnakeBody([...snakeBodyAfterMovement, {\n        x: foodPosition.x,\n        y: foodPosition.y\n      }]);\n      setFoodPosition({\n        x: randomPositionOnGrid({\n          threshold: canvasWidth\n        }),\n        y: randomPositionOnGrid({\n          threshold: canvasHeight\n        })\n      });\n    } else if (snakeBodyAfterMovement) {\n      setSnakeBody(snakeBodyAfterMovement);\n    }\n  };\n\n  useInterval(moveSnake, gameState === GameState.RUNNING ? MOVEMENT_SPEED : null);\n  return {\n    snakeBody,\n    onKeyDownHandler,\n    foodPosition,\n    resetGameState\n  };\n};\n\n_s(useGameLogic, \"CAI5RUQzPJjK6NUZMl/IreL3MNk=\", false, function () {\n  return [useInterval];\n});\n\nexport default useGameLogic;","map":{"version":3,"sources":["C:/Users/chanw/Desktop/code/canvas-snake/src/game/useGameLogic.ts"],"names":["useEffect","useState","SEGMENT_SIZE","randomPositionOnGrid","useInterval","GameState","createSnakeMovement","hasSnakeEatenItself","willSnakeHitTheFood","Direction","MOVEMENT_SPEED","useGameLogic","canvasHeight","canvasWidth","onGameOver","gameState","direction","setDirection","snakeBody","setSnakeBody","x","y","resetGameState","undefined","setFoodPosition","gridSize","threshold","foodPosition","snakeHeadPosition","length","moveDown","moveUp","moveLeft","moveRight","onKeyDownHandler","event","code","UP","DOWN","LEFT","RIGHT","moveSnake","snakeBodyAfterMovement","isGameOver","RUNNING"],"mappings":"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","sourcesContent":["import React, { useCallback, useEffect, useState } from 'react';\r\nimport { SEGMENT_SIZE } from '../draw/draw';\r\nimport randomPositionOnGrid from '../utils/randomPositionOnGrid';\r\nimport useInterval from '../utils/useInterval';\r\nimport { GameState } from './Game';\r\nimport createSnakeMovement, {\r\n  hasSnakeEatenItself,\r\n  willSnakeHitTheFood,\r\n} from './movement';\r\n\r\nexport interface Position {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport enum Direction {\r\n  UP,\r\n  DOWN,\r\n  LEFT,\r\n  RIGHT,\r\n}\r\n\r\nconst MOVEMENT_SPEED = 100;\r\n\r\ninterface UseGameLogicArgs {\r\n  canvasWidth?: number;\r\n  canvasHeight?: number;\r\n  onGameOver: () => void;\r\n  gameState: GameState;\r\n}\r\n\r\nconst useGameLogic = ({\r\n  canvasHeight,\r\n  canvasWidth,\r\n  onGameOver,\r\n  gameState,\r\n}: UseGameLogicArgs) => {\r\n  const [direction, setDirection] = useState<Direction | undefined>();\r\n  const [snakeBody, setSnakeBody] = useState<Position[]>([\r\n    {\r\n      x: 0,\r\n      y: 0,\r\n    },\r\n  ]);\r\n\r\n  const resetGameState = () => {\r\n    setDirection(undefined);\r\n    setFoodPosition({\r\n      x: randomPositionOnGrid({\r\n        gridSize: SEGMENT_SIZE,\r\n        threshold: canvasWidth!,\r\n      }),\r\n      y: randomPositionOnGrid({\r\n        gridSize: SEGMENT_SIZE,\r\n        threshold: canvasHeight!,\r\n      }),\r\n    });\r\n\r\n    setSnakeBody([\r\n      {\r\n        x: randomPositionOnGrid({\r\n          gridSize: SEGMENT_SIZE,\r\n          threshold: canvasWidth!,\r\n        }),\r\n        y: randomPositionOnGrid({\r\n          gridSize: SEGMENT_SIZE,\r\n          threshold: canvasHeight!,\r\n        }),\r\n      },\r\n    ]);\r\n  };\r\n\r\n  const [foodPosition, setFoodPosition] = useState<Position | undefined>();\r\n\r\n  const snakeHeadPosition = snakeBody[snakeBody.length - 1];\r\n  const { moveDown, moveUp, moveLeft, moveRight } = createSnakeMovement();\r\n\r\n  useEffect(() => {\r\n    if (!canvasHeight || !canvasWidth) {\r\n      return;\r\n    }\r\n    setFoodPosition({\r\n      x: randomPositionOnGrid({\r\n        gridSize: SEGMENT_SIZE,\r\n        threshold: canvasWidth,\r\n      }),\r\n      y: randomPositionOnGrid({\r\n        gridSize: SEGMENT_SIZE,\r\n        threshold: canvasHeight,\r\n      }),\r\n    });\r\n\r\n    setSnakeBody([\r\n      {\r\n        x: randomPositionOnGrid({\r\n          gridSize: SEGMENT_SIZE,\r\n          threshold: canvasWidth,\r\n        }),\r\n        y: randomPositionOnGrid({\r\n          gridSize: SEGMENT_SIZE,\r\n          threshold: canvasHeight,\r\n        }),\r\n      },\r\n    ]);\r\n  }, [canvasHeight, canvasWidth]);\r\n\r\n  const onKeyDownHandler = (event: React.KeyboardEvent<HTMLDivElement>) => {\r\n    switch (event.code) {\r\n      case 'KeyS':\r\n        if (direction !== Direction.UP) {\r\n          setDirection(Direction.DOWN);\r\n        }\r\n        break;\r\n      case 'KeyW':\r\n        if (direction !== Direction.DOWN) {\r\n          setDirection(Direction.UP);\r\n        }\r\n        break;\r\n      case 'KeyD':\r\n        if (direction !== Direction.LEFT) {\r\n          setDirection(Direction.RIGHT);\r\n        }\r\n        break;\r\n      case 'KeyA':\r\n        if (direction !== Direction.RIGHT) {\r\n          setDirection(Direction.LEFT);\r\n        }\r\n        break;\r\n    }\r\n  };\r\n\r\n  const moveSnake = () => {\r\n    let snakeBodyAfterMovement: Position[] | undefined;\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        if (snakeHeadPosition.y > 0) {\r\n          snakeBodyAfterMovement = moveUp(snakeBody);\r\n        } else if (canvasWidth && snakeHeadPosition.x > canvasWidth / 2) {\r\n          setDirection(Direction.LEFT);\r\n        } else {\r\n          setDirection(Direction.RIGHT);\r\n        }\r\n        break;\r\n      case Direction.DOWN:\r\n        if (canvasHeight && snakeHeadPosition.y < canvasHeight - SEGMENT_SIZE) {\r\n          snakeBodyAfterMovement = moveDown(snakeBody);\r\n        } else if (canvasWidth && snakeHeadPosition.x > canvasWidth / 2) {\r\n          setDirection(Direction.LEFT);\r\n        } else {\r\n          setDirection(Direction.RIGHT);\r\n        }\r\n\r\n        break;\r\n      case Direction.LEFT:\r\n        if (snakeHeadPosition.x > 0) {\r\n          snakeBodyAfterMovement = moveLeft(snakeBody);\r\n        } else if (canvasHeight && snakeHeadPosition.y < canvasHeight / 2) {\r\n          setDirection(Direction.DOWN);\r\n        } else {\r\n          setDirection(Direction.UP);\r\n        }\r\n        break;\r\n      case Direction.RIGHT:\r\n        if (canvasWidth && snakeHeadPosition.x < canvasWidth - SEGMENT_SIZE) {\r\n          snakeBodyAfterMovement = moveRight(snakeBody);\r\n        } else if (canvasHeight && snakeHeadPosition.y < canvasHeight / 2) {\r\n          setDirection(Direction.DOWN);\r\n        } else {\r\n          setDirection(Direction.UP);\r\n        }\r\n        break;\r\n    }\r\n\r\n    //snake eats itself\r\n    if (snakeBodyAfterMovement) {\r\n      const isGameOver = hasSnakeEatenItself(snakeBodyAfterMovement);\r\n      if (isGameOver) {\r\n        onGameOver();\r\n      }\r\n    }\r\n\r\n    if (\r\n      direction !== undefined &&\r\n      foodPosition &&\r\n      willSnakeHitTheFood({\r\n        foodPosition,\r\n        snakeHeadPosition,\r\n        direction,\r\n      })\r\n    ) {\r\n      setSnakeBody([\r\n        ...snakeBodyAfterMovement!,\r\n        { x: foodPosition.x, y: foodPosition.y },\r\n      ]);\r\n\r\n      setFoodPosition({\r\n        x: randomPositionOnGrid({\r\n          threshold: canvasWidth!,\r\n        }),\r\n        y: randomPositionOnGrid({ threshold: canvasHeight! }),\r\n      });\r\n    } else if (snakeBodyAfterMovement) {\r\n      setSnakeBody(snakeBodyAfterMovement);\r\n    }\r\n  };\r\n\r\n  useInterval(\r\n    moveSnake,\r\n    gameState === GameState.RUNNING ? MOVEMENT_SPEED : null\r\n  );\r\n\r\n  return {\r\n    snakeBody,\r\n    onKeyDownHandler,\r\n    foodPosition,\r\n    resetGameState,\r\n  };\r\n};\r\n\r\nexport default useGameLogic;\r\n"]},"metadata":{},"sourceType":"module"}